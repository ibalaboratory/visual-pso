using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Displays a simple line graph.
/// </summary>
public class LineGraph : MonoBehaviour
{
    [Header("Marker")]
    [SerializeField]
    private Sprite markerSprite;
    [SerializeField]
    private float markerSize = 0.05f;
    [SerializeField]
    private Color markerColor = Color.white;

    [Header("Line")]
    [SerializeField]
    private float lineWidth = 0.01f;
    [SerializeField]
    private Color lineColor = Color.white;

    [Header("Scale")]
    [SerializeField]
    private bool enableOffsetLogScale = false;


    // Child objects.
    private RectTransform plotArea;
    private Text xMinLabel;
    private Text xMaxLabel;
    private Text yMinLabel;
    private Text yMaxLabel;
    private GameObject logScaleLabel;

    // Information on  PlotArea.
    private float aspectRatio;
    private float invAspectRatio;

    // Objects generated by this script.
    private RectTransform markersParent;
    private RectTransform linesParent;
    private List<RectTransform> markers = new List<RectTransform>();
    private List<RectTransform> lines = new List<RectTransform>();
    private List<Image> markerImages = new List<Image>();
    private List<Image> lineImages = new List<Image>();


    void Start()
    {
        plotArea = transform.Find("PlotArea")?.GetComponent<RectTransform>();
        if(plotArea == null)
        {
            Debug.LogError("PlotArea not found.");
            this.enabled = false;
            return;
        }
        InitializePlotArea();

        xMinLabel = transform.Find("XMinLabel")?.GetComponent<Text>();
        xMaxLabel = transform.Find("XMaxLabel")?.GetComponent<Text>();
        yMinLabel = transform.Find("YMinLabel")?.GetComponent<Text>();
        yMaxLabel = transform.Find("YMaxLabel")?.GetComponent<Text>();
        if(xMinLabel == null || xMaxLabel == null ||
           yMinLabel == null || yMaxLabel == null)
        {
            Debug.LogError("Limits label(s) not found.");
            this.enabled = false;
            return;
        }

        logScaleLabel = transform.Find("LogScaleLabel")?.gameObject;
    }

    /// <summary>
    /// Displays a simple line graph.
    /// </summary>
    /// <param name="data">A list of (x, y) coordinates.</param>
    public void Plot(IReadOnlyList<Vector2> data)
    {
        if(data == null || data.Count == 0)
        {
            throw new System.ArgumentNullException("Argument \"data\" is null or empty.");
        }

        Clear();

        (Vector2 min, Vector2 max) = GetLimits(data);
        SetLimitLabels(min, max);

        List<Vector2> normalized = Normalize(data, min, max);

        // The first marker.
        if(markers.Count == 0) CreateMarker(normalized[0]);
        else SetMarkerPosition(markers[0], normalized[0]);
        // Re-use cached markers & lines.
        int reuseRange = Mathf.Min(markers.Count, normalized.Count);
        for(int i = 1; i < reuseRange; i++)
        {
            SetMarkerPosition(markers[i], normalized[i]);
            SetLinePosition(lines[i-1], normalized[i-1], normalized[i]);
        }
        // If there are not enough markers & lines, create new ones.
        for(int i = markers.Count; i < normalized.Count; i++)
        {
            CreateMarker(normalized[i]);
            CreateLine(normalized[i-1], normalized[i]);
        }

        SetColors();
        logScaleLabel?.SetActive(enableOffsetLogScale);
    }

    /// <summary>
    /// Clears all the markers & lines from the graph.
    /// </summary>
    public void Clear()
    {
        foreach(RectTransform marker in markers)
        {
            marker.gameObject.SetActive(false);
        }
        foreach(RectTransform line in lines)
        {
            line.gameObject.SetActive(false);
        }
    }


    private void InitializePlotArea()
    {
        if(plotArea == null) return;

        aspectRatio = plotArea.rect.width / plotArea.rect.height;
        invAspectRatio = plotArea.rect.height / plotArea.rect.width;

        linesParent = (new GameObject("Lines", typeof(RectTransform))).GetComponent<RectTransform>();
        linesParent.SetParent(plotArea, false);
        linesParent.anchorMin = Vector2.zero;
        linesParent.anchorMax = Vector2.one;
        linesParent.offsetMin = Vector2.zero;
        linesParent.offsetMax = Vector2.zero;

        markersParent = (new GameObject("Markers", typeof(RectTransform))).GetComponent<RectTransform>();
        markersParent.SetParent(plotArea, false);
        markersParent.anchorMin = Vector2.zero;
        markersParent.anchorMax = Vector2.one;
        markersParent.offsetMin = Vector2.zero;
        markersParent.offsetMax = Vector2.zero;
    }

    private (Vector2, Vector2) GetLimits(IReadOnlyList<Vector2> data)
    {
        if(data == null || data.Count == 0)
        {
            return (
                new Vector2(float.MinValue, float.MinValue),
                new Vector2(float.MaxValue, float.MaxValue)
            );
        }

        Vector2 min = new Vector2(float.MaxValue, float.MaxValue);
        Vector2 max = new Vector2(float.MinValue, float.MinValue);
        foreach(Vector2 dataPoint in data)
        {
            min.x = Mathf.Min(min.x, dataPoint.x);
            min.y = Mathf.Min(min.y, dataPoint.y);
            max.x = Mathf.Max(max.x, dataPoint.x);
            max.y = Mathf.Max(max.y, dataPoint.y);
        }

        return (min, max);
    }

    private void SetLimitLabels(Vector2 min, Vector2 max)
    {
        xMinLabel.text = $"{min.x}";
        xMaxLabel.text = $"{max.x}";
        yMinLabel.text = $"{min.y:F2}";
        yMaxLabel.text = $"{max.y:F2}";
    }

    private List<Vector2> Normalize(IReadOnlyList<Vector2> data, Vector2 min, Vector2 max)
    {
        if(data == null) return null;

        Vector2 range = max - min;
        float xScale = (range.x == 0) ? 0 : 1f / range.x;

        float yScale;
        if(enableOffsetLogScale)
        {
            float rangeLogY = OffsetLog(max.y, min.y);
            yScale = (rangeLogY == 0) ? 0 : 1f / rangeLogY;
        }
        else
        {
            yScale = (range.y == 0) ? 0 : 1f / range.y;
        }

        List<Vector2> normalized = new List<Vector2>();
        if(enableOffsetLogScale)
        {
            for(int i = 0; i < data.Count; i++)
            {
                float x = (data[i].x - min.x) * xScale;
                float y = OffsetLog(data[i].y, min.y) * yScale;
                normalized.Add(new Vector2(x, y));
            }
        }
        else
        {
            for(int i = 0; i < data.Count; i++)
            {
                float x = (data[i].x - min.x) * xScale;
                float y = (data[i].y - min.y) * yScale;
                normalized.Add(new Vector2(x, y));
            }
        }
        
        return normalized;
    }

    private float OffsetLog(float x, float offset)
    {
        return Mathf.Log10(x - offset + 1);
    }

    private void CreateMarker(Vector2 position)
    {
        GameObject markerObject = new GameObject("Marker", typeof(Image));
        markerObject.transform.SetParent(markersParent, false);

        Image markerImage = markerObject.GetComponent<Image>();
        markerImage.sprite = markerSprite;
        markerImage.color = markerColor;

        RectTransform markerTransform = markerImage.rectTransform;
        SetMarkerPosition(markerTransform, position);

        markers.Add(markerTransform);
        markerImages.Add(markerImage);
    }

    private void SetMarkerPosition(RectTransform marker, Vector2 position)
    {
        Vector2 offset = new Vector2(markerSize * invAspectRatio / 2, markerSize / 2);
        marker.anchorMin = position - offset;
        marker.anchorMax = position + offset;
        marker.offsetMin = Vector2.zero;
        marker.offsetMax = Vector2.zero;
        marker.gameObject.SetActive(true);
    }

    private void CreateLine(Vector2 positionA, Vector2 positionB)
    {
        GameObject lineObject = new GameObject("Line", typeof(Image));
        lineObject.transform.SetParent(linesParent, false);
        
        Image lineImage = lineObject.GetComponent<Image>();
        lineImage.color = lineColor;

        RectTransform lineTransform = lineImage.rectTransform;
        SetLinePosition(lineTransform, positionA, positionB);

        lines.Add(lineTransform);
        lineImages.Add(lineImage);
    }

    private void SetLinePosition(RectTransform line, Vector2 positionA, Vector2 positionB)
    {
        float modifiedY = (positionB.y - positionA.y) * invAspectRatio;
        float x = positionB.x - positionA.x;
        float distance = Mathf.Sqrt(x * x + modifiedY * modifiedY);
        Vector2 offsetX = new Vector2(distance, 0);
        Vector2 offsetY = new Vector2(0, lineWidth / 2);

        line.anchorMin = positionA - offsetY;
        line.anchorMax = positionA + offsetX + offsetY;
        line.offsetMin = Vector2.zero;
        line.offsetMax = Vector2.zero;

        line.pivot = new Vector2(0f, 0.5f);
        float angle = Mathf.Atan2(modifiedY, x);
        line.localEulerAngles = new Vector3(0, 0, Mathf.Rad2Deg * angle);
    
        line.gameObject.SetActive(true);
    }

    private void SetColors()
    {
        foreach(Image marker in markerImages)
        {
            marker.color = markerColor;
        }
        foreach(Image line in lineImages)
        {
            line.color = lineColor;
        }
    }
}
